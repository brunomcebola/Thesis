{% extends "views/base.jinja" %}
{% block title %}
  Camera {{ request.path.split("/")[-1] }}
{% endblock title %}
{% block body %}
  <div id="camera-container" class="container py-4">
    <h4>
      Camera {{ request.path.split("/")[-1] }} @ <a href="{{ url_for('gui.node', node_id=request.path.split('/')[-3] ) }}">node {{ request.path.split("/")[-3] }}</a>
    </h4>
    <div id="video-container">
      <canvas id="video"></canvas>
      <div id="controls">
        <button class="btn" id="start-pause" data-status="play">
          <i class="fas fa-play"></i>
        </button>
        <button class="btn" id="fullscreen">
          <i class="fas fa-expand"></i>
        </button>
      </div>
    </div>
  </div>
{% endblock body %}
{% block script %}
  <script>
    const node = {{ request.path.split("/")[-3] }};
    const camera = {{ request.path.split("/")[-1] }};

    const videoContainer = document.getElementById('video-container');
    const canvas = document.getElementById('video');
    const context = canvas.getContext('2d');
    const startPauseButton = document.getElementById('start-pause');
    const fullscreenButton = document.getElementById('fullscreen');

    const socket = io();  // Connect to the same origin

    function resizeCanvas() {
      // Get the computed size of the canvas
      const computedStyle = window.getComputedStyle(canvas);
      const visualWidth = parseInt(computedStyle.width, 10);
      const visualHeight = parseInt(computedStyle.height, 10);

      // Set the canvas internal resolution to match the visual size
      canvas.width = visualWidth;
      canvas.height = visualHeight;
    }

    window.addEventListener('resize', resizeCanvas);

    window.dispatchEvent(new Event('resize'));

    socket.on(`${node}_${camera}`, function(data) {
      var img = new Image();
      img.onload = function() {
        const aspectRatio = img.width / img.height;
        const canvasAspectRatio = canvas.width / canvas.height;
        let drawWidth, drawHeight, drawX, drawY;

        if (aspectRatio > canvasAspectRatio) {
          drawWidth = canvas.width;
          drawHeight = canvas.width / aspectRatio;
          drawX = 0;
          drawY = (canvas.height - drawHeight) / 2;
        } else {
          drawWidth = canvas.height * aspectRatio;
          drawHeight = canvas.height;
          drawX = (canvas.width - drawWidth) / 2;
          drawY = 0;
        }

        context.drawImage(img, drawX, drawY, drawWidth, drawHeight);
      };
      img.src = 'data:image/jpeg;base64,' + data;
    });

    fullscreenButton.addEventListener('click', function() {
      if (document.fullscreenElement) {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
      } else {
        if (videoContainer.requestFullscreen) {
          videoContainer.requestFullscreen();
        } else if (videoContainer.mozRequestFullScreen) {
          videoContainer.mozRequestFullScreen();
        } else if (videoContainer.webkitRequestFullscreen) {
          videoContainer.webkitRequestFullscreen();
        } else if (videoContainer.msRequestFullscreen) {
          videoContainer.msRequestFullscreen();
        }
      }
    });

    startPauseButton.addEventListener('click', function() {
      action = startPauseButton.dataset.status == "play" ? "start" : "stop";
      fetch(`/api/nodes/${node}/cameras/${camera}/${action}`, {
        method: 'POST'
      })
      .then(response => {
        if (response.ok) {
          var newStatus = startPauseButton.dataset.status == "play" ? "pause" : "play";
          startPauseButton.dataset.status = newStatus;
          startPauseButton.innerHTML = `<i class="fas fa-${newStatus}"></i>`;
        }
      })
    });


    // TODO: check cavas size on page load
  </script>
{% endblock script %}
